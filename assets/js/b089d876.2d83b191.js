"use strict";(self.webpackChunkkonva_site_2=self.webpackChunkkonva_site_2||[]).push([[5811],{58696:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>h,default:()=>u,frontMatter:()=>d,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"docs/sandbox/Limited_Drag_And_Resize","title":"\u5982\u4f55\u9650\u5236\u5f62\u72b6\u5728\u753b\u5e03\u821e\u53f0\u4e0a\u7684\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f","description":"\u8be5\u6f14\u793a\u5c55\u793a\u4e86\u5982\u4f55\u9650\u5236\u5f62\u72b6\u7684\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f\uff0c\u4f7f\u5176\u4fdd\u6301\u5728\u753b\u5e03\u821e\u53f0\u7684\u8fb9\u754c\u5185\u3002\u901a\u8fc7\u5b9e\u73b0\u81ea\u5b9a\u4e49\u8fb9\u754c\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u9632\u6b62\u5f62\u72b6\u79fb\u52a8\u6216\u8c03\u6574\u5230\u53ef\u89c1\u533a\u57df\u4e4b\u5916\u3002","source":"@site/content/docs/sandbox/Limited_Drag_And_Resize.mdx","sourceDirName":"docs/sandbox","slug":"/docs/sandbox/Limited_Drag_And_Resize.html","permalink":"/docs/sandbox/Limited_Drag_And_Resize.html","draft":false,"unlisted":false,"editUrl":"https://github.com/zhcndoc/konva/tree/main/content/docs/sandbox/Limited_Drag_And_Resize.mdx","tags":[],"version":"current","frontMatter":{"title":"\u5982\u4f55\u9650\u5236\u5f62\u72b6\u5728\u753b\u5e03\u821e\u53f0\u4e0a\u7684\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f","sidebar_label":"\u9650\u5236\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f","hide_table_of_contents":true,"slug":"Limited_Drag_And_Resize.html"},"sidebar":"tutorialsSidebar","previous":{"title":"\u8df3\u8dc3\u5154\u5b50","permalink":"/docs/sandbox/Jumping_Bunnies.html"},"next":{"title":"\u5982\u4f55\u5728\u753b\u5e03\u4e0a\u7ffb\u8f6c\u5f62\u72b6\u6216\u56fe\u50cf\uff1f","permalink":"/docs/sandbox/Mirror_Canvas_Shape.html"}}');var i=t(74848),s=t(28453),a=t(11470),r=t(19365);const d={title:"\u5982\u4f55\u9650\u5236\u5f62\u72b6\u5728\u753b\u5e03\u821e\u53f0\u4e0a\u7684\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f",sidebar_label:"\u9650\u5236\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f",hide_table_of_contents:!0,slug:"Limited_Drag_And_Resize.html"},h=void 0,c={},l=[];function x(n){const e={a:"a",code:"code",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"\u8be5\u6f14\u793a\u5c55\u793a\u4e86\u5982\u4f55\u9650\u5236\u5f62\u72b6\u7684\u62d6\u52a8\u548c\u8c03\u6574\u5927\u5c0f\uff0c\u4f7f\u5176\u4fdd\u6301\u5728\u753b\u5e03\u821e\u53f0\u7684\u8fb9\u754c\u5185\u3002\u901a\u8fc7\u5b9e\u73b0\u81ea\u5b9a\u4e49\u8fb9\u754c\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u9632\u6b62\u5f62\u72b6\u79fb\u52a8\u6216\u8c03\u6574\u5230\u53ef\u89c1\u533a\u57df\u4e4b\u5916\u3002"}),"\n",(0,i.jsxs)(e.p,{children:["\u8be5\u5b9e\u73b0\u7ed3\u5408\u4e86",(0,i.jsx)(e.a,{href:"https://konvajs.org/docs/drag_and_drop/Simple_Drag_Bounds.html",children:"\u62d6\u52a8\u9650\u5236\u6f14\u793a"}),"\u548c",(0,i.jsx)(e.a,{href:"https://konvajs.org/docs/select_and_transform/Resize_Limits.html",children:"\u8c03\u6574\u5927\u5c0f\u9650\u5236\u6f14\u793a"}),"\u4e2d\u7684\u6280\u672f\uff0c\u4ee5\u589e\u52a0\u5bf9\u7528\u6237\u4ea4\u4e92\u7684\u9650\u5236\u3002"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"\u8bf4\u660e\uff1a"})," \u5c1d\u8bd5\u65cb\u8f6c\u3001\u62d6\u52a8\u6216\u8c03\u6574\u5f62\u72b6\u7684\u5927\u5c0f\u3002\u6ce8\u610f\u5b83\u4eec\u5982\u4f55\u88ab\u9650\u5236\u5728\u753b\u5e03\u8fb9\u754c\u5185\u3002"]}),"\n","\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(r.A,{value:"Vanilla",default:!0,children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",metastring:"live vanilla",live:!0,children:"import Konva from 'konva';\n\n// \u8ba1\u7b97\u8fb9\u754c\u6846\u7684\u8f85\u52a9\u51fd\u6570\nfunction getCorner(pivotX, pivotY, diffX, diffY, angle) {\n  const distance = Math.sqrt(diffX * diffX + diffY * diffY);\n\n  // \u4ece\u67a2\u8f74\u5230\u62d0\u89d2\u7684\u89d2\u5ea6\n  angle += Math.atan2(diffY, diffX);\n\n  // \u83b7\u53d6\u65b0\u7684 x \u548c y \u5750\u6807\n  const x = pivotX + distance * Math.cos(angle);\n  const y = pivotY + distance * Math.sin(angle);\n\n  return { x, y };\n}\n\n// \u8ba1\u7b97\u8003\u8651\u65cb\u8f6c\u7684\u5ba2\u6237\u7aef\u77e9\u5f62\nfunction getClientRect(rotatedBox) {\n  const { x, y, width, height } = rotatedBox;\n  const rad = rotatedBox.rotation;\n\n  const p1 = getCorner(x, y, 0, 0, rad);\n  const p2 = getCorner(x, y, width, 0, rad);\n  const p3 = getCorner(x, y, width, height, rad);\n  const p4 = getCorner(x, y, 0, height, rad);\n\n  const minX = Math.min(p1.x, p2.x, p3.x, p4.x);\n  const minY = Math.min(p1.y, p2.y, p3.y, p4.y);\n  const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);\n  const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\n// \u8ba1\u7b97\u591a\u4e2a\u5f62\u72b6\u7684\u603b\u8fb9\u754c\u6846\nfunction getTotalBox(boxes) {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  boxes.forEach((box) => {\n    minX = Math.min(minX, box.x);\n    minY = Math.min(minY, box.y);\n    maxX = Math.max(maxX, box.x + box.width);\n    maxY = Math.max(maxY, box.y + box.height);\n  });\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\n// \u8bbe\u7f6e\u821e\u53f0\nconst stage = new Konva.Stage({\n  container: 'container',\n  width: window.innerWidth,\n  height: window.innerHeight,\n});\n\nconst layer = new Konva.Layer();\nstage.add(layer);\n\n// \u521b\u5efa\u7b2c\u4e00\u4e2a\u5f62\u72b6\uff08\u7ea2\u8272\u77e9\u5f62\uff09\nconst shape1 = new Konva.Rect({\n  x: stage.width() / 2 - 60,\n  y: stage.height() / 2 - 60,\n  width: 50,\n  height: 50,\n  fill: 'red',\n  draggable: true,\n});\nlayer.add(shape1);\n\n// \u521b\u5efa\u7b2c\u4e8c\u4e2a\u5f62\u72b6\uff08\u7eff\u8272\u77e9\u5f62\uff09\nconst shape2 = shape1.clone({\n  x: stage.width() / 2 + 10,\n  y: stage.height() / 2 + 10,\n  fill: 'green',\n});\nlayer.add(shape2);\n\n// \u6dfb\u52a0\u5305\u62ec\u4e24\u4e2a\u5f62\u72b6\u7684\u53d8\u5f62\u5668\nconst tr = new Konva.Transformer({\n  nodes: [shape1, shape2],\n  // \u8bbe\u7f6e\u8c03\u6574\u5927\u5c0f\u64cd\u4f5c\u7684\u8fb9\u754c\u51fd\u6570\n  boundBoxFunc: (oldBox, newBox) => {\n    // \u8ba1\u7b97\u53d8\u6362\u540e\u5f62\u72b6\u7684\u5b9e\u9645\u8fb9\u754c\u6846\n    const box = getClientRect(newBox);\n    \n    // \u68c0\u67e5\u65b0\u6846\u662f\u5426\u8d85\u51fa\u4e86\u821e\u53f0\u8fb9\u754c\n    const isOut =\n      box.x < 0 ||\n      box.y < 0 ||\n      box.x + box.width > stage.width() ||\n      box.y + box.height > stage.height();\n\n    // \u5982\u679c\u8d85\u51fa\u8fb9\u754c\uff0c\u4fdd\u6301\u65e7\u6846\n    if (isOut) {\n      return oldBox;\n    }\n    \n    // \u5982\u679c\u5728\u8fb9\u754c\u5185\uff0c\u5141\u8bb8\u53d8\u6362\n    return newBox;\n  },\n});\nlayer.add(tr);\n\n// \u5904\u7406\u62d6\u52a8\u4e8b\u4ef6\u4ee5\u4fdd\u6301\u5f62\u72b6\u5728\u821e\u53f0\u5185\ntr.on('dragmove', () => {\n  // \u83b7\u53d6\u6240\u6709\u9009\u5b9a\u8282\u70b9\u7684\u5ba2\u6237\u7aef\u77e9\u5f62\n  const boxes = tr.nodes().map((node) => node.getClientRect());\n  \n  // \u83b7\u53d6\u6240\u6709\u5f62\u72b6\u7684\u603b\u8fb9\u754c\u6846\n  const box = getTotalBox(boxes);\n  \n  // \u4fdd\u6301\u5f62\u72b6\u5728\u821e\u53f0\u8fb9\u754c\u5185\n  tr.nodes().forEach((shape) => {\n    const absPos = shape.getAbsolutePosition();\n    \n    // \u8ba1\u7b97\u5f62\u72b6\u4f4d\u7f6e\u76f8\u5bf9\u4e8e\u7ec4\u8fb9\u754c\u6846\n    const offsetX = box.x - absPos.x;\n    const offsetY = box.y - absPos.y;\n\n    // \u5982\u679c\u8d85\u51fa\u8fb9\u754c\uff0c\u8c03\u6574\u4f4d\u7f6e\n    const newAbsPos = { ...absPos };\n    \n    if (box.x < 0) {\n      newAbsPos.x = -offsetX;\n    }\n    if (box.y < 0) {\n      newAbsPos.y = -offsetY;\n    }\n    if (box.x + box.width > stage.width()) {\n      newAbsPos.x = stage.width() - box.width - offsetX;\n    }\n    if (box.y + box.height > stage.height()) {\n      newAbsPos.y = stage.height() - box.height - offsetY;\n    }\n    \n    shape.setAbsolutePosition(newAbsPos);\n  });\n});\n"})})}),(0,i.jsx)(r.A,{value:"React",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",metastring:"live react",live:!0,children:"import { useState, useEffect, useRef } from 'react';\nimport { Stage, Layer, Rect, Transformer } from 'react-konva';\n\n// \u8ba1\u7b97\u8fb9\u754c\u6846\u7684\u8f85\u52a9\u51fd\u6570\nconst getCorner = (pivotX, pivotY, diffX, diffY, angle) => {\n  const distance = Math.sqrt(diffX * diffX + diffY * diffY);\n  angle += Math.atan2(diffY, diffX);\n  const x = pivotX + distance * Math.cos(angle);\n  const y = pivotY + distance * Math.sin(angle);\n  return { x, y };\n};\n\nconst getClientRect = (rotatedBox) => {\n  const { x, y, width, height } = rotatedBox;\n  const rad = rotatedBox.rotation;\n\n  const p1 = getCorner(x, y, 0, 0, rad);\n  const p2 = getCorner(x, y, width, 0, rad);\n  const p3 = getCorner(x, y, width, height, rad);\n  const p4 = getCorner(x, y, 0, height, rad);\n\n  const minX = Math.min(p1.x, p2.x, p3.x, p4.x);\n  const minY = Math.min(p1.y, p2.y, p3.y, p4.y);\n  const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);\n  const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n};\n\nconst getTotalBox = (boxes) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  boxes.forEach((box) => {\n    minX = Math.min(minX, box.x);\n    minY = Math.min(minY, box.y);\n    maxX = Math.max(maxX, box.x + box.width);\n    maxY = Math.max(maxY, box.y + box.height);\n  });\n  \n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n};\n\nconst LimitedDragAndResize = () => {\n  const [stageSize, setStageSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n  \n  const [shapes, setShapes] = useState([\n    {\n      id: 'rect1',\n      x: window.innerWidth / 2 - 60,\n      y: window.innerHeight / 2 - 60,\n      width: 50,\n      height: 50,\n      fill: 'red',\n    },\n    {\n      id: 'rect2',\n      x: window.innerWidth / 2 + 10,\n      y: window.innerHeight / 2 + 10,\n      width: 50,\n      height: 50,\n      fill: 'green',\n    }\n  ]);\n  \n  const shapeRefs = useRef(new Map());\n  const trRef = useRef(null);\n  \n  // \u5728\u5c42\u88c5\u8f7d\u540e\u8bbe\u7f6e\u53d8\u5f62\u5668\n  useEffect(() => {\n    if (trRef.current) {\n      const nodes = shapes.map(shape => shapeRefs.current.get(shape.id));\n      trRef.current.nodes(nodes);\n    }\n  }, [shapes]);\n  \n  // \u5904\u7406\u7a97\u53e3\u5927\u5c0f\u8c03\u6574\n  useEffect(() => {\n    const handleResize = () => {\n      setStageSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // \u53d8\u5f62\u5668\u7684\u8fb9\u754c\u51fd\u6570\n  const boundBoxFunc = (oldBox, newBox) => {\n    const box = getClientRect(newBox);\n    \n    const isOut =\n      box.x < 0 ||\n      box.y < 0 ||\n      box.x + box.width > stageSize.width ||\n      box.y + box.height > stageSize.height;\n      \n    if (isOut) {\n      return oldBox;\n    }\n    \n    return newBox;\n  };\n  \n  // \u5904\u7406\u53d8\u5f62\u5668\u7ec4\u7684\u62d6\u52a8\n  const handleTransformerDrag = (e) => {\n    if (!trRef.current) return;\n    \n    const nodes = trRef.current.nodes();\n    if (nodes.length === 0) return;\n    \n    const boxes = nodes.map(node => node.getClientRect());\n    const box = getTotalBox(boxes);\n    \n    nodes.forEach(shape => {\n      const absPos = shape.getAbsolutePosition();\n      const offsetX = box.x - absPos.x;\n      const offsetY = box.y - absPos.y;\n      \n      const newAbsPos = { ...absPos };\n      \n      if (box.x < 0) {\n        newAbsPos.x = -offsetX;\n      }\n      if (box.y < 0) {\n        newAbsPos.y = -offsetY;\n      }\n      if (box.x + box.width > stageSize.width) {\n        newAbsPos.x = stageSize.width - box.width - offsetX;\n      }\n      if (box.y + box.height > stageSize.height) {\n        newAbsPos.y = stageSize.height - box.height - offsetY;\n      }\n      \n      shape.setAbsolutePosition(newAbsPos);\n    });\n  };\n  \n  return (\n    <Stage width={stageSize.width} height={stageSize.height}>\n      <Layer>\n        {shapes.map(shape => (\n          <Rect\n            key={shape.id}\n            ref={(node) => {\n              if (node) shapeRefs.current.set(shape.id, node);\n            }}\n            x={shape.x}\n            y={shape.y}\n            width={shape.width}\n            height={shape.height}\n            fill={shape.fill}\n            draggable\n          />\n        ))}\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={boundBoxFunc}\n          onDragMove={handleTransformerDrag}\n        />\n      </Layer>\n    </Stage>\n  );\n};\n\nexport default LimitedDragAndResize;\n"})})}),(0,i.jsx)(r.A,{value:"Vue",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",metastring:"live vue",live:!0,children:"<template>\n  <v-stage :config=\"stageConfig\">\n    <v-layer>\n      <v-rect\n        v-for=\"(rect, i) in rectangles\"\n        :key=\"i\"\n        :config=\"rect\"\n        @dragmove=\"handleRectDragMove\"\n      />\n      <v-transformer\n        ref=\"transformerRef\"\n        :config=\"transformerConfig\"\n        @dragmove=\"handleTransformerDragMove\"\n      />\n    </v-layer>\n  </v-stage>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      stageConfig: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n      },\n      rectangles: [\n        {\n          x: window.innerWidth / 2 - 60,\n          y: window.innerHeight / 2 - 60,\n          width: 50,\n          height: 50,\n          fill: 'red',\n          draggable: true,\n          id: 'rect1',\n          name: 'my-rect'\n        },\n        {\n          x: window.innerWidth / 2 + 10,\n          y: window.innerHeight / 2 + 10,\n          width: 50,\n          height: 50,\n          fill: 'green',\n          draggable: true,\n          id: 'rect2',\n          name: 'my-rect'\n        }\n      ],\n      transformerConfig: {\n        nodes: [],\n      }\n    };\n  },\n  mounted() {\n    // \u5728\u7ec4\u4ef6\u6302\u8f7d\u540e\u8bbe\u7f6e\u53d8\u5f62\u5668\u8282\u70b9\n    this.$nextTick(() => {\n      const transformer = this.$refs.transformerRef.getNode();\n      const rects = transformer.getStage().find('.my-rect');\n      \n      // \u8bbe\u7f6e\u53d8\u5f62\u5668\u4ee5\u5904\u7406\u4e24\u4e2a\u77e9\u5f62\n      transformer.nodes(rects);\n      \n      // \u4e3a\u53d8\u5f62\u5668\u6dfb\u52a0\u8fb9\u754c\u51fd\u6570\n      transformer.boundBoxFunc(this.boundBoxFunc);\n    });\n    \n    // \u5904\u7406\u7a97\u53e3\u5927\u5c0f\u8c03\u6574\n    window.addEventListener('resize', this.handleResize);\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.handleResize);\n  },\n  methods: {\n    getCorner(pivotX, pivotY, diffX, diffY, angle) {\n      const distance = Math.sqrt(diffX * diffX + diffY * diffY);\n      angle += Math.atan2(diffY, diffX);\n      const x = pivotX + distance * Math.cos(angle);\n      const y = pivotY + distance * Math.sin(angle);\n      return { x, y };\n    },\n    \n    getClientRect(rotatedBox) {\n      const { x, y, width, height } = rotatedBox;\n      const rad = rotatedBox.rotation || 0;\n\n      const p1 = this.getCorner(x, y, 0, 0, rad);\n      const p2 = this.getCorner(x, y, width, 0, rad);\n      const p3 = this.getCorner(x, y, width, height, rad);\n      const p4 = this.getCorner(x, y, 0, height, rad);\n\n      const minX = Math.min(p1.x, p2.x, p3.x, p4.x);\n      const minY = Math.min(p1.y, p2.y, p3.y, p4.y);\n      const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);\n      const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);\n\n      return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY,\n      };\n    },\n    \n    getTotalBox(boxes) {\n      let minX = Infinity;\n      let minY = Infinity;\n      let maxX = -Infinity;\n      let maxY = -Infinity;\n\n      boxes.forEach((box) => {\n        minX = Math.min(minX, box.x);\n        minY = Math.min(minY, box.y);\n        maxX = Math.max(maxX, box.x + box.width);\n        maxY = Math.max(maxY, box.y + box.height);\n      });\n      \n      return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY,\n      };\n    },\n    \n    boundBoxFunc(oldBox, newBox) {\n      const box = this.getClientRect(newBox);\n      \n      const isOut =\n        box.x < 0 ||\n        box.y < 0 ||\n        box.x + box.width > this.stageConfig.width ||\n        box.y + box.height > this.stageConfig.height;\n        \n      if (isOut) {\n        return oldBox;\n      }\n      \n      return newBox;\n    },\n    \n    handleTransformerDragMove(e) {\n      const transformer = this.$refs.transformerRef.getNode();\n      const nodes = transformer.nodes();\n      \n      if (!nodes.length) return;\n      \n      const boxes = nodes.map(node => node.getClientRect());\n      const box = this.getTotalBox(boxes);\n      \n      nodes.forEach(shape => {\n        const absPos = shape.getAbsolutePosition();\n        const offsetX = box.x - absPos.x;\n        const offsetY = box.y - absPos.y;\n        \n        const newAbsPos = { x: absPos.x, y: absPos.y };\n        \n        if (box.x < 0) {\n          newAbsPos.x = -offsetX;\n        }\n        if (box.y < 0) {\n          newAbsPos.y = -offsetY;\n        }\n        if (box.x + box.width > this.stageConfig.width) {\n          newAbsPos.x = this.stageConfig.width - box.width - offsetX;\n        }\n        if (box.y + box.height > this.stageConfig.height) {\n          newAbsPos.y = this.stageConfig.height - box.height - offsetY;\n        }\n        \n        shape.setAbsolutePosition(newAbsPos);\n      });\n    },\n    \n    handleRectDragMove(e) {\n      // \u5355\u4e2a\u77e9\u5f62\u7684\u62d6\u52a8\u5904\u7406\u7531\u53d8\u5f62\u5668\u5904\u7406\n    },\n    \n    handleResize() {\n      this.stageConfig.width = window.innerWidth;\n      this.stageConfig.height = window.innerHeight;\n    }\n  }\n}\n<\/script>\n"})})})]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(x,{...n})}):x(n)}},19365:(n,e,t)=>{t.d(e,{A:()=>a});t(96540);var o=t(34164);const i={tabItem:"tabItem_Ymn6"};var s=t(74848);function a({children:n,hidden:e,className:t}){return(0,s.jsx)("div",{role:"tabpanel",className:(0,o.A)(i.tabItem,t),hidden:e,children:n})}},11470:(n,e,t)=>{t.d(e,{A:()=>X});var o=t(96540),i=t(34164),s=t(17559),a=t(23104),r=t(56347),d=t(205),h=t(57485),c=t(31682),l=t(70679);function x(n){return o.Children.toArray(n).filter((n=>"\n"!==n)).map((n=>{if(!n||(0,o.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(n){const{values:e,children:t}=n;return(0,o.useMemo)((()=>{const n=e??function(n){return x(n).map((({props:{value:n,label:e,attributes:t,default:o}})=>({value:n,label:e,attributes:t,default:o})))}(t);return function(n){const e=(0,c.XI)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[e,t])}function f({value:n,tabValues:e}){return e.some((e=>e.value===n))}function g({queryString:n=!1,groupId:e}){const t=(0,r.W6)(),i=function({queryString:n=!1,groupId:e}){if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,h.aZ)(i),(0,o.useCallback)((n=>{if(!i)return;const e=new URLSearchParams(t.location.search);e.set(i,n),t.replace({...t.location,search:e.toString()})}),[i,t])]}function m(n){const{defaultValue:e,queryString:t=!1,groupId:i}=n,s=u(n),[a,r]=(0,o.useState)((()=>function({defaultValue:n,tabValues:e}){if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!f({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=e.find((n=>n.default))??e[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:e,tabValues:s}))),[h,c]=g({queryString:t,groupId:i}),[x,m]=function({groupId:n}){const e=function(n){return n?`docusaurus.tab.${n}`:null}(n),[t,i]=(0,l.Dv)(e);return[t,(0,o.useCallback)((n=>{e&&i.set(n)}),[e,i])]}({groupId:i}),b=(()=>{const n=h??x;return f({value:n,tabValues:s})?n:null})();(0,d.A)((()=>{b&&r(b)}),[b]);return{selectedValue:a,selectValue:(0,o.useCallback)((n=>{if(!f({value:n,tabValues:s}))throw new Error(`Can't select invalid tab value=${n}`);r(n),c(n),m(n)}),[c,m,s]),tabValues:s}}var b=t(92303);const p={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=t(74848);function y({className:n,block:e,selectedValue:t,selectValue:o,tabValues:s}){const r=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.a_)(),h=n=>{const e=n.currentTarget,i=r.indexOf(e),a=s[i].value;a!==t&&(d(e),o(a))},c=n=>{let e=null;switch(n.key){case"Enter":h(n);break;case"ArrowRight":{const t=r.indexOf(n.currentTarget)+1;e=r[t]??r[0];break}case"ArrowLeft":{const t=r.indexOf(n.currentTarget)-1;e=r[t]??r[r.length-1];break}}e?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":e},n),children:s.map((({value:n,label:e,attributes:o})=>(0,w.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:n=>{r.push(n)},onKeyDown:c,onClick:h,...o,className:(0,i.A)("tabs__item",p.tabItem,o?.className,{"tabs__item--active":t===n}),children:e??n},n)))})}function v({lazy:n,children:e,selectedValue:t}){const s=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const n=s.find((n=>n.props.value===t));return n?(0,o.cloneElement)(n,{className:(0,i.A)("margin-top--md",n.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:s.map(((n,e)=>(0,o.cloneElement)(n,{key:e,hidden:n.props.value!==t})))})}function Y(n){const e=m(n);return(0,w.jsxs)("div",{className:(0,i.A)(s.G.tabs.container,"tabs-container",p.tabList),children:[(0,w.jsx)(y,{...e,...n}),(0,w.jsx)(v,{...e,...n})]})}function X(n){const e=(0,b.A)();return(0,w.jsx)(Y,{...n,children:x(n.children)},String(e))}},28453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>r});var o=t(96540);const i={},s=o.createContext(i);function a(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);